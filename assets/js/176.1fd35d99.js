(window.webpackJsonp=window.webpackJsonp||[]).push([[176],{769:function(t,e,a){"use strict";a.r(e);var s=a(6),v=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("最近面试过程中遇到了这个问题，感觉自己之前对这部分的理解还是很片面，所以决定整理一下。")]),t._v(" "),a("p",[t._v("浏览器缓存是浏览器在本地磁盘对用户最近请求过的资源进行存储，当再次访问统一资源时，就可以直接使用缓存，可以减少与服务器的数据传输，减小服务器的负担，提高页面响应速度等")])]),a("h2",{attrs:{id:"请求过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请求过程"}},[t._v("#")]),t._v(" 请求过程🔗")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("浏览器在第一次请求后缓存资源，再次请求时，会进行下面两个步骤：")]),t._v(" "),a("ul",[a("li",[t._v("浏览器发起对于某资源的请求时，会先检查本地是否存在缓存，如果存在则通过"),a("code",[t._v("expires")]),t._v("和"),a("code",[t._v("cache-control")]),t._v("检查缓存是否有效，如果命中缓存且缓存未过期，则不会向服务器发起请求，直接使用缓存资源")]),t._v(" "),a("li",[t._v("若未命中本地缓存，浏览器就会向服务器发送一个协商请求，通过"),a("code",[t._v("Last-Modified-Since")]),t._v("或者"),a("code",[t._v("IF-None-Match")]),t._v("(这两个字段的值，分别是第一次请求返回的"),a("code",[t._v("Last-Modified/Etag")]),t._v(")来向服务器验证是否命中协商缓存 :\n"),a("ul",[a("li",[t._v("如果命中，服务器会返回304状态码，且此次响应不会返回资源内容，浏览器直接使用缓存")]),t._v(" "),a("li",[t._v("如果未命中，服务器则会返回200状态码，并返回资源的实际内容，同时更新"),a("code",[t._v("header")]),t._v("中的字段")])])])])]),a("h2",{attrs:{id:"强缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[t._v("#")]),t._v(" 强缓存📦")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("​\t强缓存是通过"),a("code",[t._v("Expires")]),t._v("和"),a("code",[t._v("Cache-Control")]),t._v("来控制缓存在本地的有效期的")])]),a("h3",{attrs:{id:"expires"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[t._v("#")]),t._v(" Expires")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("​\t"),a("code",[t._v("Expires")]),t._v("是"),a("code",[t._v("HTTP1.0")]),t._v("提出的一个表示资源过期时间的"),a("code",[t._v("request header")]),t._v(",它"),a("strong",[t._v("描述的是一个绝对时间")]),t._v(",由服务器返回。"),a("code",[t._v("Expires")]),t._v("受限于本地时间，如果修改本地时间，可能会造成缓存失效。对于一个资源的请求，如果在"),a("code",[t._v("Expires")]),t._v("内，则浏览器会直接使用缓存，不请求服务器")]),t._v(" "),a("p",[t._v("​\t格式如下:")])]),a("div",{staticClass:"language-http line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-http"}},[a("code",[a("span",{pre:!0,attrs:{class:"token header"}},[a("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Expires")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("Sun, 14 Jun 2020 02:50:57 GMT")])]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("h3",{attrs:{id:"cache-control"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[t._v("#")]),t._v(" Cache-Control")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[a("code",[t._v("Cache-Control")]),t._v("出现于"),a("code",[t._v("HTTP1.1")]),t._v(","),a("strong",[t._v("优先级高于"),a("code",[t._v("Expires")])]),t._v(",它描述的是相对时间，请求头和响应头都支持这个字段，用来定义缓存策略")]),t._v(" "),a("p",[t._v("​\t格式如下：")])]),a("div",{staticClass:"language-http line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-http"}},[a("code",[a("span",{pre:!0,attrs:{class:"token header"}},[a("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Cache-Control")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("max-age=300")])]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("ul",[a("li",[a("code",[t._v("Cache-Control: no-store")]),t._v(":  禁止浏览器缓存数据，每次请求资源都会向服务器要完整的资源")]),t._v(" "),a("li",[a("code",[t._v("Cache-Control: no-cache")]),t._v(":  不使用本地缓存，需要使用协商缓存")]),t._v(" "),a("li",[a("code",[t._v("Cache-Control: public | private")]),t._v(":\n"),a("ul",[a("li",[a("code",[t._v("private")]),t._v(": 默认值。表示只能应用于浏览器私有缓存中")]),t._v(" "),a("li",[a("code",[t._v("public")]),t._v(": 表示该响应可以被任何中间人，中间代理，"),a("code",[t._v("CDN")]),t._v("等缓存。")])])]),t._v(" "),a("li",[a("code",[t._v("Cache-Control: max-age=xxx")]),t._v(": 响应的最大过期时间，单位是s。表示资源能够被缓存的时间(即保持新鲜的最大事件)，"),a("code",[t._v("max-age")]),t._v("是距离请求发起的时间的秒数")]),t._v(" "),a("li",[a("code",[t._v("Cache-Control: must-revalidate")]),t._v(": 当使用了"),a("code",[t._v("must-revalidate")]),t._v("指令，那就意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已过期的缓存将不被使用。在正常情况下是没有必要使用这个指令的，因为在强缓存过期的情况下会进行协商缓存，但是"),a("code",[t._v("HTTP")]),t._v("规范是允许客户端在某些特殊情况下直接使用过期缓存的，比如校验请求发送失败的时候，还比如有配置一些特殊指令"),a("code",[t._v("stale-while-revalidate")]),t._v("、"),a("code",[t._v("stale-if-error")]),t._v("等的时候，"),a("code",[t._v("must-revalidate")]),t._v("指令就是让缓存在过期后的任何情况下都必须重新验证。")])])]),a("h2",{attrs:{id:"协商缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存📦")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("​\t当浏览器对某个资源的请求没有命中强缓存，就会发送一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的状态码为"),a("code",[t._v("304(Not Modified)")]),t._v(",该请求不携带实体数据；若未命中，则返回"),a("code",[t._v("200状态码")]),t._v("并携带资源实体数据。")]),t._v(" "),a("p",[t._v("​\t协商缓存主要利用的是"),a("code",[t._v("Last-Modified、IF-Modified-Since")]),t._v("和"),a("code",[t._v("ETag、IF-None-Match")]),t._v("这两对字段来控制的。")])]),a("h3",{attrs:{id:"last-modified、if-modified-since"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#last-modified、if-modified-since"}},[t._v("#")]),t._v(" Last-Modified、IF-Modified-Since")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("​\t在"),a("code",[t._v("HTTP1.0")]),t._v("引入。"),a("code",[t._v("Last-Modified")]),t._v("表示"),a("strong",[t._v("本地文件的最后修改日期")]),t._v("，浏览器会在请求头上加上"),a("code",[t._v("IF-Modified-Since")]),t._v("(也就是上次相应的"),a("code",[t._v("Last-Modified")]),t._v("的值)，来询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。")]),t._v(" "),a("p",[t._v("​\t但是，如果在本地打开缓存文件，就会导致"),a("code",[t._v("Last-Modified")]),t._v("被修改，所以在"),a("code",[t._v("HTTP1.1")]),t._v("出现了"),a("code",[t._v("ETag")])])]),a("h3",{attrs:{id:"etag、if-none-match"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#etag、if-none-match"}},[t._v("#")]),t._v(" ETag、IF-None-Match")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"}),a("p",[t._v("​\t"),a("code",[t._v("ETag")]),t._v("是"),a("strong",[t._v("服务器为资源生成的唯一标识串")]),t._v("，资源发生变化会导致"),a("code",[t._v("Etag")]),t._v("变化，跟最后修改时间没有关系，所以"),a("code",[t._v("ETag")]),t._v("可以保证每个资源是唯一的。"),a("code",[t._v("IF-None-Match")]),t._v("的请求字段会将上次返回的"),a("code",[t._v("ETag")]),t._v("发送给服务器，来询问该资源的"),a("code",[t._v("ETag")]),t._v("是否有更新，如果有变动就会发送新的资源回来。")]),t._v(" "),a("p",[a("code",[t._v("ETag")]),t._v("的优先级比"),a("code",[t._v("Last-Modified")]),t._v("高,在以下类似情况，应该优先使用"),a("code",[t._v("ETag")]),t._v(":")]),t._v(" "),a("ul",[a("li",[t._v("一些文件也许会周期性的更改，但是他的内容并不改变，比如仅仅改变的修改时间，这个时候我们并不希望客户端认为这个文件被修改了，而重新"),a("code",[t._v("GET")])]),t._v(" "),a("li",[t._v("某些文件修改非常频繁，比如在秒以下的时间内进行修改，例如"),a("code",[t._v("1s")]),t._v("内修改了"),a("code",[t._v("N")]),t._v("次，"),a("code",[t._v("If-Modified-Since")]),t._v("能检查到的粒度是秒级的，这种修改无法判断")]),t._v(" "),a("li",[t._v("某些服务器不能精确的得到文件的最后修改时间")])])])])}),[],!1,null,null,null);e.default=v.exports}}]);