(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{631:function(t,v,s){"use strict";s.r(v);var _=s(6),i=Object(_.a)({},(function(){var t=this,v=t.$createElement,s=t._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"浏览器渲染的大致流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染的大致流程"}},[t._v("#")]),t._v(" 浏览器渲染的大致流程")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"}),s("p",[t._v("​\t在\t"),s("code",[t._v("HTML")]),t._v("中，每个元素都可以被视为一个'盒子'，在浏览器解析渲染过程中，会涉及到回流和重绘:")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("回流(重排): 布局引擎根据各种样式计算每个盒子在页面上的大小和位置等，也就是几何信息")])]),t._v(" "),s("li",[s("strong",[t._v("重绘：根据计算好的几何信息，浏览器对每个盒子进行绘制")])])])]),s("p",[s("img",{attrs:{src:"https://fastly.jsdelivr.net/gh/Ocean-H1/blog_image_bed/rendering.png",alt:"浏览器渲染机制"}})]),t._v(" "),s("ul",[s("li",[t._v("解析HTML，生成DOM树，解析CSS，生成CSSOM")]),t._v(" "),s("li",[t._v("将DOM树和CSSOM结合，生成渲染树(render tree)")]),t._v(" "),s("li",[t._v("Layout(回流): 根据生成的渲染树，进行回流，得到节点的几何信息")]),t._v(" "),s("li",[t._v("Painting(重绘): 根据得到的几何信息以及渲染树，得到节点的绝对像素")]),t._v(" "),s("li",[t._v("Display: 将像素发送给GPU，展示在页面上")])]),t._v(" "),s("h2",{attrs:{id:"回流和重绘的触发时机"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回流和重绘的触发时机"}},[t._v("#")]),t._v(" 回流和重绘的触发时机")]),t._v(" "),s("h3",{attrs:{id:"回流"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回流"}},[t._v("#")]),t._v(" 回流")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"}),s("p",[t._v("​\t回流这一阶段，主要是计算节点的几何信息，所以当页面布局和几何信息发生变化的时候，就会触发回流，比如下面的情况:")]),t._v(" "),s("ul",[s("li",[t._v("页面一开始渲染的时候(无法避免)\n"),s("ul",[s("li",[t._v("因为页面一开始相当于是空白的没有元素，后面添加了元素使页面布局发生变化")])])]),t._v(" "),s("li",[t._v("添加或删除DOM元素")]),t._v(" "),s("li",[t._v("显示或隐藏DOM元素")]),t._v(" "),s("li",[t._v("元素的位置发生变化")]),t._v(" "),s("li",[t._v("元素的尺寸发生变化(如大小宽高、边距等)")]),t._v(" "),s("li",[t._v("浏览器窗口尺寸变化\n"),s("ul",[s("li",[s("strong",[t._v("因为回流是根据视口的大小来计算节点的几何信息的")])])])]),t._v(" "),s("li",[t._v("获取一些特定的属性值\n"),s("ul",[s("li",[t._v("比如: offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight。"),s("strong",[t._v("这些属性值都需要通过即时计算得到，所以浏览器为了获得这些值，也会进行回流")])])])])])]),s("h3",{attrs:{id:"重绘"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重绘"}},[t._v("#")]),t._v(" 重绘")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"}),s("ul",[s("li",[s("strong",[t._v("触发回流一定会发生重绘")])]),t._v(" "),s("li",[t._v("颜色的修改")]),t._v(" "),s("li",[t._v("阴影的修改")]),t._v(" "),s("li",[t._v("文本方向的修改等")])])]),s("h3",{attrs:{id:"浏览器优化机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器优化机制"}},[t._v("#")]),t._v(" 浏览器优化机制")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"}),s("p",[t._v("​\t\t由于每次回流(重排)都会造成额外的计算消耗，所以大多数浏览器会通过 "),s("strong",[t._v("队列化修改并批量执行")]),t._v("来优化重排过程。浏览器会将修改操作放到队列中，直到过了一段时间或者操作达到了设置的阈值，才会清空队列。")]),t._v(" "),s("p",[t._v("​\t\t当你获取布局信息的操作的时候，会强制队列刷新，包括前面讲到的"),s("code",[t._v("offsetTop")]),t._v("等方法都会返回最新的数据。因此浏览器不得不清空队列，触发回流重绘来返回正确的值")])]),s("h2",{attrs:{id:"如何减少回流和重绘的发生"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何减少回流和重绘的发生"}},[t._v("#")]),t._v(" 如何减少回流和重绘的发生")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"}),s("ul",[s("li",[t._v("如果要给同个元素同时设置多个样式，使用类名去合并样式，"),s("strong",[t._v("然后通过添加")]),t._v("/删除类名来达到目的")]),t._v(" "),s("li",[s("strong",[t._v("避免设置多项内联样式")])]),t._v(" "),s("li",[t._v("对于复杂的动画效果，对其设置"),s("code",[t._v("position: fixed / absolute")]),t._v("，"),s("strong",[t._v("尽可能使元素脱离文档流")]),t._v("，从而减少对其他元素的影响")]),t._v(" "),s("li",[s("strong",[t._v("使用css3硬件加速")]),t._v(",可以让"),s("code",[t._v("transform")]),t._v("、"),s("code",[t._v("opacity")]),t._v("、"),s("code",[t._v("filters")]),t._v("这些动画不会引起回流重绘")]),t._v(" "),s("li",[s("strong",[t._v("避免使用 CSS 的 "),s("code",[t._v("JavaScript")]),t._v(" 表达式")])]),t._v(" "),s("li",[t._v("在使用"),s("code",[t._v("JavaScript")]),t._v("动态插入多个节点时，可以使用"),s("code",[t._v("DocumentFragment")]),t._v("(文档碎片)。创建后一次性插入，避免多次的渲染")]),t._v(" "),s("li",[t._v("有时候，我们需要修改元素的布局，那么就很有可能用到上文提到过的那些需要即时计算的属性(offsetTop、offsetLeft...),如果每次循环都进行获取，性能比较糟糕，可以使用变量进行缓存，计算完毕后再提交给浏览器发出重计算请求")]),t._v(" "),s("li",[t._v("我们还可以通过通过设置元素属性"),s("code",[t._v("display: none")]),t._v("，将其从页面上去掉，然后再进行后续操作，这些后续操作也不会触发回流与重绘，这个过程称为离线操作")])])])])}),[],!1,null,null,null);v.default=i.exports}}]);